**libraries**

```{r}
# ---- CHUNK 1 (revised): Setup & Normalize using UA travel times only ----
library(tidyverse)
library(lubridate)

objs_loaded <- load("emsData.RData")
ems <- if ("ems" %in% objs_loaded) get("ems") else if ("x" %in% objs_loaded) get("x") else stop("No 'ems' or 'x' in emsData.RData")

# Helper: safely coerce to POSIXct if not already
to_posix <- function(x) if (inherits(x, "POSIXt")) x else ymd_hms(x, quiet = TRUE)

# Ensure UA columns exist (create as NA if missing so mutate won’t error)
ua_needed <- c("eTT.UA.Ce", "eTT.UA.So", "eTT.UA.NN", "eTT.UA.FN")
for (nm in ua_needed) if (!nm %in% names(ems)) ems[[nm]] <- NA_real_

# Build standardized incident table
ems_std <- ems %>%
  mutate(
    dispatch_at = to_posix(DT.DISP),
    clear_at    = to_posix(DT.AVAILABLE),
    service_secs = as.numeric(difftime(clear_at, dispatch_at, units = "secs")),

    # UA travel times only (seconds); keep as numeric
    tt_central    = eTT.UA.Ce,
    tt_south      = eTT.UA.So,
    tt_near_north = eTT.UA.NN,
    tt_far_north  = eTT.UA.FN
  ) %>%
  arrange(dispatch_at) %>%
  group_by(dispatch_at) %>%
  slice(1) %>%                      # one row per incident (first record at that dispatch time)
  ungroup() %>%
  mutate(incident_id = row_number()) %>%
  select(
    incident_id, dispatch_at, clear_at, service_secs,
    REF.GRID, DISPATCH.PRIORITY.NAME, BASE.NAME, VEH.GRID,
    tt_central, tt_south, tt_near_north, tt_far_north
  )

# Light checks so we know what we have
message("Rows: ", nrow(ems_std))
message("Missing dispatch_at: ", sum(is.na(ems_std$dispatch_at)))
message("Missing clear_at: ", sum(is.na(ems_std$clear_at)))
message("Non-positive service_secs: ", sum(!is.na(ems_std$service_secs) & ems_std$service_secs <= 0))
summary(select(ems_std, tt_central, tt_south, tt_near_north, tt_far_north))

```

```{r}
scenarios <- tibble::tribble(
  ~scenario, ~units,
  "S1", list(c(Central=3, South=1)),
  "S2", list(c(Central=3, NearNorth=1)),
  "S3", list(c(Central=3, FarNorth=1)),
  "S4", list(c(Central=2, NearNorth=1, South=1)),
  "S5", list(c(Central=2, FarNorth=1, South=1))
)

station_tt_map <- c(
  Central   = "tt_central",
  NearNorth = "tt_near_north",
  FarNorth  = "tt_far_north",
  South     = "tt_south"
)
```

```{r}
# ---- PATCHED simulate_scenario(): NA/edge-case safe ----

simulate_scenario <- function(incidents, units_cfg_named_vec) {
  # normalize: keep names even if it was a list/list-col
  counts_raw <- units_cfg_named_vec
  if (is.list(counts_raw)) {
    counts_raw <- unlist(counts_raw, recursive = TRUE, use.names = TRUE)
  }
  # coerce to numeric with names intact
  counts <- as.integer(counts_raw)
  nms    <- names(counts_raw)
  if (is.null(nms) || anyNA(nms) || length(nms) == 0) {
    stop("Scenario 'units_cfg' must be a *named* numeric vector, e.g. c(Central=2, South=1).")
  }
  if (sum(counts, na.rm = TRUE) <= 0) stop("Scenario has zero units.")

  # ----- keep the rest of your function body unchanged -----
  station_vec <- rep(nms, times = counts)
  seq_per_station <- ave(seq_along(station_vec), station_vec, FUN = seq_along)
  unit_id_vec <- paste0(station_vec, "_", seq_per_station)
  t0 <- suppressWarnings(min(incidents$dispatch_at, na.rm = TRUE))
  if (!is.finite(as.numeric(t0))) stop("All incident dispatch times are NA.")
  fleet <- data.frame(
    station   = station_vec,
    unit_id   = unit_id_vec,
    next_free = t0 - lubridate::seconds(1),
    stringsAsFactors = FALSE
  )

  # helper: map station -> travel-time column in 'incidents'
  tt_col_for <- function(st) switch(st,
    "Central"   = "tt_central",
    "South"     = "tt_south",
    "NearNorth" = "tt_near_north",
    "FarNorth"  = "tt_far_north",
    stop("Unknown station in scenario: ", st)
  )

  # 2) Sim loop
  nI <- nrow(incidents)
  out_list <- vector("list", nI)

  for (i in seq_len(nI)) {
    call_t <- incidents$dispatch_at[i]
    if (is.na(call_t)) next

    svc <- incidents$service_secs[i]
    if (is.na(svc) || svc < 0) svc <- 0

    # per-unit travel times to THIS incident (NA -> Inf)
    tt_cols <- vapply(fleet$station, tt_col_for, character(1))
    tt_vals <- vapply(tt_cols, function(col) {
      val <- incidents[[col]][i]
      if (is.null(val) || is.na(val)) Inf else as.numeric(val)
    }, numeric(1))

    # availability (NA -> FALSE)
    avail <- fleet$next_free <= call_t
    avail[is.na(avail)] <- FALSE

    if (!any(avail)) {
      nf <- as.numeric(fleet$next_free); nf[is.na(nf)] <- Inf
      chosen <- which.min(nf); if (length(chosen) == 0) chosen <- 1
      wait_s <- max(0, as.numeric(difftime(fleet$next_free[chosen], call_t, units = "secs")))
      travel_s <- if (is.finite(tt_vals[chosen])) tt_vals[chosen] else 0
      depart_time <- fleet$next_free[chosen]
    } else {
      idx <- which(avail)
      finite_tt <- tt_vals[idx]
      if (!any(is.finite(finite_tt))) {
        chosen <- idx[1]
        travel_s <- 0
      } else {
        chosen <- idx[which.min(finite_tt)]
        travel_s <- tt_vals[chosen]
      }
      wait_s <- 0
      depart_time <- call_t
    }

    # update fleet
    fleet$next_free[chosen] <- depart_time + lubridate::seconds(wait_s + travel_s + svc)

    # record
    out_list[[i]] <- tibble::tibble(
      incident_id        = incidents$incident_id[i],
      assigned_station   = fleet$station[chosen],
      assigned_unit      = fleet$unit_id[chosen],
      wait_secs          = wait_s,
      travel_secs        = travel_s,
      total_response_secs = wait_s + travel_s
    )
  }

  dplyr::bind_rows(out_list)
}

```

```{r}
# ---- CHUNK 3b: Redefine incidents to match the other group ----

ems_for_inc <- ems %>%
  mutate(
    dispatch_at  = to_posix(DT.DISP),
    clear_at     = to_posix(DT.AVAILABLE),
    service_secs = as.numeric(difftime(clear_at, dispatch_at, units = "secs")),
    # UA-only travel times
    tt_central    = eTT.UA.Ce,
    tt_south      = eTT.UA.So,
    tt_near_north = eTT.UA.NN,
    tt_far_north  = eTT.UA.FN
  ) %>%
  arrange(dispatch_at) %>%
  group_by(dispatch_at, BASE.NAME) %>%
  slice(1) %>%
  ungroup() %>%
  mutate(incident_id = row_number()) %>%
  select(incident_id, dispatch_at, clear_at, service_secs,
         tt_central, tt_south, tt_near_north, tt_far_north)


```

```{r}

# ---- CHUNK 4: Define scenarios and run them ----

inc <- ems_for_inc %>%
  filter(!is.na(dispatch_at),
         !is.na(service_secs),
         service_secs >= 0) %>%
  # keep incidents with at least one available travel time
  filter(rowSums(!is.na(select(., tt_central, tt_south, tt_near_north, tt_far_north))) >= 1) %>%
  arrange(dispatch_at)

# Scenarios stored as named numeric vectors (not lists of lists)
scenarios <- tibble::tibble(
  scenario  = c("S1","S2","S3","S4","S5"),
  units_cfg = list(
    c(Central = 3, South     = 1),
    c(Central = 3, NearNorth = 1),
    c(Central = 3, FarNorth  = 1),
    c(Central = 2, NearNorth = 1, South = 1),
    c(Central = 2, FarNorth  = 1, South = 1)
  )
)


# Run each scenario
sim_results <- scenarios %>%
  mutate(sim = purrr::map(units_cfg, ~ simulate_scenario(inc, .x))) %>%
  select(scenario, sim) %>%
  tidyr::unnest(sim) %>%
  left_join(inc %>% select(incident_id, service_secs), by = "incident_id") %>%
  mutate(total_time_secs = total_response_secs + service_secs)

# Coerce to plain numeric seconds and recompute totals
sim_results <- sim_results %>%
  mutate(
    wait_secs           = as.numeric(wait_secs),
    travel_secs         = as.numeric(travel_secs),
    service_secs        = as.numeric(service_secs),
    total_response_secs = as.numeric(wait_secs + travel_secs),
    total_time_secs     = as.numeric(total_response_secs + service_secs)
  )


# Keep only finite, plausible response times (0–2 hours)
sim_results_clean <- sim_results %>%
  filter(is.finite(total_response_secs),
         total_response_secs >= 0,
         total_response_secs <= 2*60*60)

sim_results_clean
```

```{r}
cat("\n--- object sizes ---\n")
for (nm in c("ems_std","ems_for_inc","inc","sim_results","sim_results_clean")) {
  if (exists(nm)) cat(nm, ": nrow =", nrow(get(nm)), "\n")
}

cat("\n--- column classes in sim_results_clean ---\n")
print(sapply(sim_results_clean %>%
               select(scenario, wait_secs, travel_secs, service_secs,
                      total_response_secs, total_time_secs),
             function(x) paste(class(x), collapse=" / ")))

cat("\n--- quick summaries (should be a few hundred seconds) ---\n")
print(summary(sim_results_clean$total_response_secs))

cat("\n--- any impossible values? (> 2 hrs) ---\n")
bad <- sim_results_clean %>%
  filter(!is.finite(total_response_secs) |
         total_response_secs < 0 |
         total_response_secs > 2*60*60)
print(nrow(bad))
print(head(bad, 5))

cat("\n--- are you summarizing the CLEAN table? ---\n")
summ_tbl_check <- sim_results_clean %>%
  group_by(scenario) %>%
  summarise(mean_resp = mean(total_response_secs), .groups="drop")
print(summ_tbl_check)


```

```{r}
# ---- CHUNK 5: Summaries & Plots ----
library(tidyverse)
library(scales)

# Response-time summaries (travel + wait)
summ_tbl <- sim_results_clean %>%
  group_by(scenario) %>%
  summarise(
    n               = n(),
    mean_resp_s     = mean(total_response_secs),
    median_resp_s   = median(total_response_secs),
    p90_resp_s      = quantile(total_response_secs, 0.90),
    p95_resp_s      = quantile(total_response_secs, 0.95),
    pct_under_8min  = mean(total_response_secs <= 8*60),
    pct_under_10min = mean(total_response_secs <= 10*60),
    .groups = "drop"
  ) %>%
  arrange(mean_resp_s)

print(summ_tbl)

# Boxplot of response times by scenario (cap extreme tails for readability)
plot_df <- sim_results_clean %>%
  mutate(scenario = factor(scenario, levels = sort(unique(scenario))))

ggplot(plot_df, aes(x = scenario, y = total_response_secs)) +
  geom_boxplot(outlier.alpha = 0.2) +
  scale_y_continuous("Total Response (s)",
                     labels = scales::label_number(accuracy = 1)) +
  labs(title = "Response Time Distributions by Scenario") +
  theme_minimal()


# Boxplot
ggplot(plot_df, aes(x = scenario, y = total_response_secs)) +
  geom_boxplot(outlier.alpha = 0.2) +
  scale_y_continuous("Total Response (s)",
                     labels = scales::label_number(accuracy = 1)) +
  labs(title = "Response Time Distributions by Scenario") +
  theme_minimal()

# ECDF
ggplot(sim_results_clean, aes(x = total_response_secs, color = scenario)) +
  stat_ecdf(geom = "step") +
  scale_x_continuous("Total Response (s)",
                     labels = scales::label_number(accuracy = 1)) +
  labs(title = "ECDF of Total Response Times") +
  theme_minimal()


```

```{r}
# ---- CHUNK 6b: Logistic models for on-time performance ----

library(tidyverse)

logit_df <- sim_results_clean %>%
  transmute(
    incident_id,
    scenario = factor(scenario),
    rt_sec   = as.numeric(total_response_secs),
    ontime_8  = as.integer(rt_sec <= 8*60),
    ontime_10 = as.integer(rt_sec <= 10*60)
  ) %>%
  # keep rows where the binary outcomes are defined
  filter(!is.na(ontime_8), !is.na(ontime_10)) %>%
  mutate(scenario = relevel(scenario, ref = "S1"))

use_lme4 <- requireNamespace("lme4", quietly = TRUE)

if (use_lme4) {
  library(lme4)

  # Mixed-effects logistic (random intercept by incident)
  m8  <- glmer(ontime_8  ~ scenario + (1 | incident_id),
               data = logit_df, family = binomial(link = "logit"),
               control = glmerControl(optimizer = "bobyqa"))
  m10 <- glmer(ontime_10 ~ scenario + (1 | incident_id),
               data = logit_df, family = binomial(link = "logit"),
               control = glmerControl(optimizer = "bobyqa"))

  cat("\n--- Mixed-effects logistic: ≤ 8 minutes (baseline S1) ---\n")
  print(summary(m8))
  cat("\n--- Mixed-effects logistic: ≤ 10 minutes (baseline S1) ---\n")
  print(summary(m10))

  # Odds ratios with 95% CIs
  or_ci <- function(mod) {
    est <- suppressWarnings(coef(summary(mod)))
    tibble(
      term = rownames(est),
      OR   = exp(est[, "Estimate"]),
      LCL  = exp(est[, "Estimate"] - 1.96*est[, "Std. Error"]),
      UCL  = exp(est[, "Estimate"] + 1.96*est[, "Std. Error"])
    ) %>%
      filter(term != "(Intercept)") %>%
      mutate(scenario = sub("^scenario", "", term)) %>%
      select(scenario, OR, LCL, UCL)
  }

  or8  <- or_ci(m8)
  or10 <- or_ci(m10)

  # Scenario-level predicted probabilities (marginal at typical incident)
  invlogit <- function(x) 1/(1+exp(-x))
  pred_tbl <- function(mod, title) {
    cf  <- fixef(mod) # fixed effects
    scs <- levels(logit_df$scenario)
    tibble(scenario = scs) %>%
      mutate(
        lp = cf["(Intercept)"] + c(0, cf[paste0("scenarios", scs[-1])]),
        # above line assumes contrast naming like scenarioS2, S3, ...
        # safer approach (handles any contrast names):
        lp = map_dbl(scenario, ~{
          if (.x == scs[1]) cf["(Intercept)"]
          else {
            nm <- names(cf)[grepl("^scenario", names(cf)) & grepl(.x, names(cf))]
            cf["(Intercept)"] + if (length(nm)==1) cf[nm] else 0
          }
        }),
        p  = invlogit(lp)
      ) %>% select(scenario, p) %>% arrange(scenario) %>% mutate(model = title)
  }

  preds8  <- pred_tbl(m8,  "≤8 min")
  preds10 <- pred_tbl(m10, "≤10 min")

  # Save outputs
  readr::write_csv(or8,  "logit_or_le8min.csv")
  readr::write_csv(or10, "logit_or_le10min.csv")
  bind_rows(preds8, preds10) %>% readr::write_csv("logit_pred_probs_by_scenario.csv")

} else {
  # Fallback: fixed-effects logistic with cluster-robust SE by incident (no random effects)
  # Requires fixest >= 0.11.2
  if (!requireNamespace("fixest", quietly = TRUE)) {
    stop("Neither lme4 nor fixest are available. Install one of them to run logistic models.")
  }
  library(fixest)

  fe8  <- feglm(ontime_8  ~ i(scenario, ref = "S1") | incident_id,
                data = logit_df, family = "logit", cluster = ~ incident_id)
  fe10 <- feglm(ontime_10 ~ i(scenario, ref = "S1") | incident_id,
                data = logit_df, family = "logit", cluster = ~ incident_id)

  cat("\n--- Fixed-effects logistic (clustered): ≤ 8 minutes ---\n");  print(summary(fe8))
  cat("\n--- Fixed-effects logistic (clustered): ≤ 10 minutes ---\n"); print(summary(fe10))

  # Odds ratios
  or_tbl <- function(mod) {
    co <- broom::tidy(mod) %>%
      filter(str_detect(term, "scenario::")) %>%
      mutate(
        scenario = sub("^i\\(scenario, ref = \"S1\"\\)::", "", term),
        OR  = exp(estimate),
        LCL = exp(estimate - 1.96*std.error),
        UCL = exp(estimate + 1.96*std.error)
      ) %>% select(scenario, OR, LCL, UCL)
    co
  }

  if (!requireNamespace("broom", quietly = TRUE)) install.packages("broom")
  library(broom)

  or8  <- or_tbl(fe8)
  or10 <- or_tbl(fe10)

  # Predicted probabilities by scenario (marginal effects at means)
  invlogit <- function(x) 1/(1+exp(-x))
  pred_tbl_fixest <- function(mod, title) {
    scs <- levels(logit_df$scenario)
    # Get baseline intercept (fixest hides fixed effects; use S1 coefficient = 0 reference)
    tibble(scenario = scs) %>%
      mutate(
        beta = ifelse(scenario == "S1", 0,
                      coef(mod)[paste0("i(scenario, ref = \"S1\")::", scenario)] %||% 0),
        # center at average FE (approximate marginal): works for comparisons
        p = invlogit(beta)
      ) %>% select(scenario, p) %>% arrange(scenario) %>% mutate(model = title)
  }

  `%||%` <- function(a,b) if (!is.null(a)) a else b

  preds8  <- pred_tbl_fixest(fe8,  "≤8 min")
  preds10 <- pred_tbl_fixest(fe10, "≤10 min")

  readr::write_csv(or8,  "logit_or_le8min.csv")
  readr::write_csv(or10, "logit_or_le10min.csv")
  bind_rows(preds8, preds10) %>% readr::write_csv("logit_pred_probs_by_scenario.csv")
}

# Quick glance in-session
cat("\n--- Odds ratios (≤8 min) ---\n"); print(or8)
cat("\n--- Odds ratios (≤10 min) ---\n"); print(or10)
cat("\n--- Predicted probabilities by scenario ---\n"); print(bind_rows(preds8, preds10))

```

```{r}
# ---- CHUNK 7 (robust): Diagnostics ----

safe_re <- function(mod, grp = "incident_id") {
  if (!inherits(mod, "merMod")) return(numeric(0))
  re_list <- try(lme4::ranef(mod, condVar = FALSE), silent = TRUE)
  if (inherits(re_list, "try-error")) return(numeric(0))
  if (!grp %in% names(re_list)) return(numeric(0))
  vec <- suppressWarnings(as.numeric(re_list[[grp]][,"(Intercept)"]))
  vec[is.finite(vec)]
}

# ----- Seconds model -----
if (exists("m") && inherits(m, "merMod")) {
  par(mfrow = c(1, 2), las = 1)

  # Residuals vs Fitted
  plot(fitted(m), resid(m),
       xlab = "Fitted (s)", ylab = "Residuals (s)",
       main = "Residuals vs Fitted (seconds)")
  abline(h = 0, col = "gray60")

  # QQ plot residuals
  qqnorm(resid(m), main = "QQ Plot Residuals (seconds)")
  qqline(resid(m), col = "gray60")

  # Random effects QQ (only if available)
  re_int <- safe_re(m, "incident_id")
  if (length(re_int) > 1) {
    par(mfrow = c(1, 1), las = 1)
    qqnorm(re_int, main = "QQ Plot Random Intercepts (seconds)")
    qqline(re_int, col = "gray60")
  } else {
    message("Skipped random-effects QQ (seconds): no finite random effects to plot.")
  }
}

# ----- Log-seconds model -----
if (exists("m_log") && inherits(m_log, "merMod")) {
  par(mfrow = c(1, 2), las = 1)

  # Residuals vs Fitted
  plot(fitted(m_log), resid(m_log),
       xlab = "Fitted log(s)", ylab = "Residuals",
       main = "Residuals vs Fitted (log seconds)")
  abline(h = 0, col = "gray60")

  # QQ plot residuals
  qqnorm(resid(m_log), main = "QQ Plot Residuals (log seconds)")
  qqline(resid(m_log), col = "gray60")

  # Random effects QQ (only if available)
  re_int_log <- safe_re(m_log, "incident_id")
  if (length(re_int_log) > 1) {
    par(mfrow = c(1, 1), las = 1)
    qqnorm(re_int_log, main = "QQ Plot Random Intercepts (log)")
    qqline(re_int_log, col = "gray60")
  } else {
    message("Skipped random-effects QQ (log): no finite random effects to plot.")
  }
}

```
